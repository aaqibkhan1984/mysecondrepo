package com.dru.care.app.patientdiary.dao;


import com.dru.care.app.patientdiary.bean.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.BatchPreparedStatementSetter;
import org.springframework.jdbc.core.BeanPropertyRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import javax.management.ListenerNotFoundException;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;


@Repository
public class PatientBeanDaoImp implements PatientBeanDao {

	@Autowired
	private JdbcTemplate jdbcTemplate;


	@Autowired
	private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

//@Value("${queryForInsertStudent}")
	private String queryForInsertPatient;


//@Value("${queryForUpdateStudent}")
	private String queryForUpdatePatient;

//@Value("${queryForSoftDeleteStudent}")
	private String queryForSoftDeletePatient;

//	@Value("${insertStudentQuery}")
	private String insertQuery;

//	@Value("${updateStudentQuery}")
	private String updateQuery;

//	@Value("${softDeleteStudentQuery}")
	private String softDeleteQuery;

//	@Value("${queryForObjectSelectDataInJdbcT}")
	String queryObjectSelectDataInJdbcTemplete;

//	@Value("${queryForInsertStudentAutoGeneratedKey}")
	private String insertQueryForStudent;

//	@Value("${queryForListSelectDataInJdbcT}")
	private String queryListSelectDataInJdbcTemplete;


//	@Value("${queryForMapSelectDataInJdbcT}")
	private String queryForMapSelectDataInJdbcT;


//	@Value("${queryForObjectSelectDataInNamedT}")
	private  String queryForObjectSelectDataInNamedTem;

//	@Value("${queryForListSelectDataInNamedT}")
	private String  queryForListSelectDataInNamedTem;
	
//	@Value("${queryForMapSelectDataInNamedT}")
	private String queryForMapSelectDataInNamedTem;


//	@Value("${queryForInsertStudentDepXref}")
	private  String  queryForInsertStudentDepXre;


//	@Value("${queryForUpdateStudentDepXref}")
	private  String queryForUpdateStudentDepXre;


//	@Value("${queryForStudentByGenderq}")
	private String queryForStudentByGender;

	@Override
	public Boolean insertPatientBeanUsingMap(InsertPatient insertPatient) {


		int update = 0;
		try {
			Map<String, Object> map = new HashMap<>();

			map.put("getPatientId", insertPatient.getPatientId());
			map.put("firstName", insertPatient.getFirstName());
			map.put("lastName", insertPatient.getLastName());
			map.put("gender", insertPatient.getGender());
			map.put("address", insertPatient.getAddress());
			map.put("email", insertPatient.getEmail());
			map.put("phone", insertPatient.getPhone());
			map.put("major", insertPatient.getMajor());
			map.put("getDescription", insertPatient.getDescription());
			map.put("gpa", insertPatient.getGpa());
			map.put("totalMArks", insertPatient.getTotalMArks());
		
			

			update = namedParameterJdbcTemplate.update(queryForInsertPatient, map);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return update > 0;

	}

	@Override
	public Boolean insertPatientBeanUsingMapSqlParameter(InsertPatient insertPatient) {
		int update = 0;

		try {
			MapSqlParameterSource parameter = new MapSqlParameterSource();
			parameter.addValue("PatientId",insertPatient.getPatientId());
			parameter.addValue("firstName", insertPatient.getFirstName());
			parameter.addValue("lastName", insertPatient.getLastName());
			parameter.addValue("gender", insertPatient.getGender());
			parameter.addValue("address", insertPatient.getAddress());
			parameter.addValue("email", insertPatient.getEmail());
			parameter.addValue("phone", insertPatient.getPhone());
			parameter.addValue("major", insertPatient.getMajor());
			parameter.addValue("getDescription", insertPatient.getDescription());
			parameter.addValue("getEntryDate",insertPatient.getEntryDate());
			parameter.addValue("gpa", insertPatient.getGpa());
			parameter.addValue("totalMArks", insertPatient.getTotalMArks());

			update = namedParameterJdbcTemplate.update(queryForInsertPatient, parameter);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return update > 0;

	}


	@Override
	public Boolean insertPatientBeanUsingBeanProperty(InsertPatient insertPatient) {
		int update = 0;
		try {
			update = namedParameterJdbcTemplate.update(queryForInsertPatient,
					new BeanPropertySqlParameterSource(insertPatient));

		} catch (Exception e) {
			e.printStackTrace();
		}

		return update > 0;
	}

	public Boolean updatePatientBeanUsingMap(UpdatePatient updatePatient) {
		int update = 0;

		try {
			MapSqlParameterSource parameter = new MapSqlParameterSource();
			parameter.addValue("PatientId",updatePatient.getPatientId());
			parameter.addValue("firstName", updatePatient.getFirstName());
			parameter.addValue("lastName", updatePatient.getLastName());
			parameter.addValue("dateOfBirth", updatePatient.getDateOfBirth());
			parameter.addValue("gender", updatePatient.getGender());
			parameter.addValue("address", updatePatient.getAddress());
			parameter.addValue("email", updatePatient.getEmail());
			parameter.addValue("phone", updatePatient.getPhone());
			parameter.addValue("major", updatePatient.getMajor());
			parameter.addValue("getDescription", updatePatient.getDescription());
			parameter.addValue("getEntryDate",updatePatient.getEntryDate());
			parameter.addValue("gpa", updatePatient.getGpa());
			parameter.addValue("totalMArks", updatePatient.getTotalMArks());


			update = namedParameterJdbcTemplate.update(queryForUpdatePatient, parameter);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return update > 0;
	}

	@Override
	public Boolean updatePatientBeanUsingBeanProperty(UpdatePatient updatePatient) {
		int update = 0;
		try {
			update = namedParameterJdbcTemplate.update(queryForUpdatePatient,
					new BeanPropertySqlParameterSource(updatePatient));

		} catch (Exception e) {
			e.printStackTrace();
		}
		return update > 0;
	}

	@Override
	public Boolean softDeletePatientBeanUsingMap(DeletePatient deletePatient) {
		int update = 0;
		try {
			Map<String, Object> map = new HashMap<>();
			map.put("patientId", deletePatient.getPatientId());
			update = namedParameterJdbcTemplate.update(queryForSoftDeletePatient, map);

		} catch (Exception e) {
			e.printStackTrace();
		}
		return update > 0;
	}

	@Override
	public Boolean softDeletePateintBeanUsingMapSqlParameter(DeletePatient deletePatient) {
		int update = 0;
		try {
			MapSqlParameterSource parameters = new MapSqlParameterSource();
			parameters.addValue("", deletePatient.getPatientId());
			update = namedParameterJdbcTemplate.update(queryForSoftDeletePatient, parameters);

		} catch (Exception e) {
			e.printStackTrace();
		}
		return update > 0;
	}

	@Override
	public Boolean softDeletePatientBeanUsingBeanParameter(DeletePatient deletePatient) {
		int update = 0;
		try {
			update = namedParameterJdbcTemplate.update(queryForSoftDeletePatient,
					new BeanPropertySqlParameterSource(deletePatient));

		} catch (Exception e) {
			e.printStackTrace();
		}
		return update > 0;
	}


	////////////////////////// Batch insert Pateint  using NamedParameterJdbcTemplate with createBatch/////////////////////////////

	public Boolean batchInsertForPatientBean(List<InsertPatient> insertPatients) {
		int[] batchUpdate = null;
		try {
			batchUpdate = namedParameterJdbcTemplate.batchUpdate(queryForInsertPatient,
					SqlParameterSourceUtils.createBatch(insertPatients.toArray()));

		} catch (Exception e) {
			e.printStackTrace();

		}
		return insertPatients.size() == (batchUpdate != null ? batchUpdate.length : 0);
	}


	// //////////////////Batch insert Pateint  using NamedParameterJdbcTemplate with mapSqlParameterSources/////////////////////////


	public Boolean batchInsertForPatientBeanUsingMapSqlParameterSource(List<InsertPatient> insertPatients) {
		MapSqlParameterSource[] mapSqlParameterSource = new MapSqlParameterSource[insertPatients.size()];
		int i = 0;
		int[] batchUpdate = null;
		try {

			for (InsertPatient insertPatient : insertPatients) {
				MapSqlParameterSource parameter = new MapSqlParameterSource();
				parameter.addValue("PatientId",insertPatient.getPatientId());
				parameter.addValue("firstName", insertPatient.getFirstName());
				parameter.addValue("lastName", insertPatient.getLastName());
				parameter.addValue("gender", insertPatient.getGender());
				parameter.addValue("address", insertPatient.getAddress());
				parameter.addValue("email", insertPatient.getEmail());
				parameter.addValue("phone", insertPatient.getPhone());
				parameter.addValue("major", insertPatient.getMajor());
				parameter.addValue("getDescription", insertPatient.getDescription());
				parameter.addValue("getEntryDate",insertPatient.getEntryDate());
				parameter.addValue("gpa", insertPatient.getGpa());
				parameter.addValue("totalMArks", insertPatient.getTotalMArks());

				mapSqlParameterSource[i] = parameter;
				i++;
			}
			batchUpdate = namedParameterJdbcTemplate.batchUpdate(queryForInsertPatient, mapSqlParameterSource);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return insertPatients.size() == (batchUpdate != null ? batchUpdate.length : 0);
	}


	//////////////////////////Batch update Pateint  using NamedParameterJdbcTemplate with createBatch////////////////////////////

	public Boolean batchUpdateForPatientBean(List<UpdatePatient> updatePatients) {
		int[] batchUpdate = null;
		try {
			batchUpdate = namedParameterJdbcTemplate.batchUpdate(queryForUpdatePatient,
					SqlParameterSourceUtils.createBatch(updatePatients.toArray()));

		} catch (Exception e) {
			e.printStackTrace();

		}
		return updatePatients.size() == (batchUpdate != null ? batchUpdate.length : 0);
	}


///////////////////////////// Batch update patient using NamedParameterJdbcTemplate with mapSqlParameterSources ///////////////////////


	public Boolean batchUpdateForPatientBeanUsingMapSqlParameterSource(List<UpdatePatient> updateStudents) {

		MapSqlParameterSource[] mapSqlParameterSource = new MapSqlParameterSource[updateStudents.size()];
		int i = 0;
		int[] batchUpdate = null;
		try {

			for (UpdatePatient insertPatient : updateStudents) {
				MapSqlParameterSource parameter = new MapSqlParameterSource();

				parameter.addValue("PatientId",insertPatient.getPatientId());
				parameter.addValue("firstName", insertPatient.getFirstName());
				parameter.addValue("lastName", insertPatient.getLastName());
				parameter.addValue("gender", insertPatient.getGender());
				parameter.addValue("address", insertPatient.getAddress());
				parameter.addValue("email", insertPatient.getEmail());
				parameter.addValue("phone", insertPatient.getPhone());
				parameter.addValue("major", insertPatient.getMajor());
				parameter.addValue("getDescription", insertPatient.getDescription());
				parameter.addValue("getEntryDate",insertPatient.getEntryDate());
				parameter.addValue("gpa", insertPatient.getGpa());
				parameter.addValue("totalMArks", insertPatient.getTotalMArks());
				mapSqlParameterSource[i] = parameter;
				i++;
			}

			batchUpdate = namedParameterJdbcTemplate.batchUpdate(queryForUpdatePatient, mapSqlParameterSource);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return updateStudents.size() == (batchUpdate != null ? batchUpdate.length : 0);
	}


/////////////////////////////////// Batch delete Pateint using NamedParameterJdbcTemplate with createBatch//////////

	public Boolean batchSoftDeleteForPatientBean(List<DeletePatient> deletePatients) {
		int[] batchUpdate = null;
		try {
			batchUpdate = namedParameterJdbcTemplate.batchUpdate(queryForSoftDeletePatient,
					SqlParameterSourceUtils.createBatch(deletePatients));

		} catch (Exception e) {
			e.printStackTrace();
		}
		return deletePatients.size() == (batchUpdate != null ? batchUpdate.length : 0);
	}

	////////////////////////////// Batch Soft delete Pateint using NamedParameterJdbcTemplate with mapSqlParameterSources

	public Boolean batchSoftDeleteForPatientBeanUsingMapSqlParameterSource(List<DeletePatient> deletePatients) {
		MapSqlParameterSource[] mapSqlParameterSource = new MapSqlParameterSource[deletePatients.size()];
		int i = 0;
		int[] batchUpdate = null;
		try {

			for (DeletePatient delete : deletePatients) {
				MapSqlParameterSource params = new MapSqlParameterSource();
				params.addValue("patientId", delete.getPatientId());
				mapSqlParameterSource[i] = params;
				i++;
			}

			batchUpdate = namedParameterJdbcTemplate.batchUpdate(queryForSoftDeletePatient, mapSqlParameterSource);
		} catch (Exception e) {
			e.printStackTrace();
		}
		return deletePatients.size() == (batchUpdate != null ? batchUpdate.length : 0);
	}


	// Batch insert Patient using JdbcTemplate with BatchPreparedStatementSetter
	public Boolean batchInsertForPatientBeanUsingJdbcTemplate(List<InsertPatient> insertPatients) {
		int[] batchUpdate = null;
		try {

			batchUpdate = jdbcTemplate.batchUpdate(insertQuery, new BatchPreparedStatementSetter() {


				@Override
				public void setValues(PreparedStatement ps, int i) throws SQLException {

					InsertPatient insert = insertPatients.get(i);


					ps.setLong(1, insert.getPatientId());
					ps.setString(2, insert.getLastName());
					ps.setString(3, insert.getGender());
					ps.setString(4, insert.getAddress());
					ps.setString(5, insert.getEmail());
					ps.setString(6, insert.getPhone());
					ps.setString(7, insert.getMajor());
					ps.setString(8, insert.getDescription());
					ps.setDouble(9, insert.getGpa());
					ps.setInt(10, insert.getTotalMArks());


				}

				@Override
				public int getBatchSize() {
					// TODO Auto-generated method stub
					return insertPatients.size();
				}

			});
		} catch (Exception e) {
			e.printStackTrace();
		}
		return insertPatients.size() == (batchUpdate != null ? batchUpdate.length : 0);

	}

	// Batch update PAteint using JdbcTemplate with  BatchPreparedStatementSetter //////
	public Boolean batchUpdateForPatientBeanUsingJdbcTemplate(List<UpdatePatient> updatePatients) {
		int[] batchUpdate = null;
		try {

			batchUpdate = jdbcTemplate.batchUpdate(updateQuery, new BatchPreparedStatementSetter() {

				@Override
				public void setValues(PreparedStatement ps, int i) throws SQLException {


					ps.setLong(1, updatePatients.get(i).getPatientId());
					ps.setString(2, updatePatients.get(i).getFirstName());
					ps.setString(3, updatePatients.get(i).getLastName());
					ps.setDate(4, java.sql.Date.valueOf(updatePatients.get(i).getDateOfBirth()));
					ps.setString(5, updatePatients.get(i).getGender());
					ps.setString(6, updatePatients.get(i).getAddress());
					ps.setString(7, updatePatients.get(i).getEmail());
					ps.setString(8, updatePatients.get(i).getPhone());
					ps.setString(9, updatePatients.get(i).getMajor());
					ps.setString(10, updatePatients.get(i).getDescription());
					ps.setDate(11, java.sql.Date.valueOf(updatePatients.get(i).getEntryDate()));
					ps.setDouble(12, updatePatients.get(i).getGpa());
					ps.setInt(13, updatePatients.get(i).getTotalMArks());
					ps.setBoolean(14, updatePatients.get(i).getIsActive());

				}

				@Override
				public int getBatchSize() {
					// TODO Auto-generated method stub
					return updatePatients.size();
				}

			});
		} catch (Exception e) {
			e.printStackTrace();
		}
		return updatePatients.size() == (batchUpdate != null ? batchUpdate.length : 0);

	}

	@Override
	public Boolean batchSoftDeleteForPatientBeanUsingJdbcTemplate(List<DeletePatient> deletePatients) {
		int[] batchUpdate = null;
		try {

			batchUpdate = jdbcTemplate.batchUpdate(softDeleteQuery, new BatchPreparedStatementSetter() {

				@Override
				public void setValues(PreparedStatement ps, int i) throws SQLException {

					ps.setLong(1, deletePatients.get(i).getPatientId());

				}

				@Override
				public int getBatchSize() {
					// TODO Auto-generated method stub
					return deletePatients.size();
				}

			});
		} catch (Exception e) {
			e.printStackTrace();
		}
		return deletePatients.size() == (batchUpdate != null ? batchUpdate.length : 0);
	}


	/////////////////////////////////////////////////////////////////////////////////
	@Override
	public boolean batchInsertUpdateForPateintBeanUsingNamedParameterJdbcTemplateInsert(
			List<InsertUpdatePateintBean> saveInsertUpdatePateintBeans) {
		return namedParameterJdbcTemplate.batchUpdate(queryForInsertPatient, SqlParameterSourceUtils.createBatch(saveInsertUpdatePateintBeans.toArray())).length == saveInsertUpdatePateintBeans.size();
	}

	@Override
	public boolean batchInsertUpdateForPateintBeanUsingNamedParameterJdbcTemplateUpdate(
			List<InsertUpdatePateintBean> updatePateintBeans) {

		return namedParameterJdbcTemplate.batchUpdate(queryForUpdatePatient, SqlParameterSourceUtils.createBatch(updatePateintBeans.toArray())).length == updatePateintBeans.size();


	}

	
	
	










	////////////// ///////////////////////////////                   
	//////////////////////////
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	/////////////////////////////////////////////////////////////////////////////////////////////////


	public Long insertPateintDetailsAndReturnAutoGeratedKey(InsertPatient insertPatient) {

		String sql = "INSERT INTO pateint_info_ref(first_name, last_name, gender, address, email, phone, major, description,, gpa, total_marks) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

		KeyHolder keyHolder = new GeneratedKeyHolder();

		jdbcTemplate.update(con -> {

			PreparedStatement ps = con.prepareStatement(sql);

			ps.setString(1, insertPatient.getFirstName());
			ps.setString(2, insertPatient.getLastName());
			ps.setString(3, insertPatient.getGender());
			ps.setString(4, insertPatient.getAddress());
			ps.setString(5, insertPatient.getEmail());
			ps.setString(6, insertPatient.getPhone());
			ps.setString(7, insertPatient.getMajor());
			ps.setString(8, insertPatient.getDescription());
			ps.setDouble(9, insertPatient.getGpa());
			ps.setInt(10, insertPatient.getTotalMArks());

			return ps;
		}, keyHolder);


		Number generatedKey = keyHolder.getKey();
		Long patientId = (generatedKey != null) ? generatedKey.longValue() : null;

		System.out.println("Generated Pateint ID: " + patientId );


		return (Long) keyHolder.getKey();

	}

	@Override
	public Boolean insertPateintDetailsAndReturnAutoGeratedKeyboolean(InsertPatient insertPatient) {

		try {

			KeyHolder keyHolder = new GeneratedKeyHolder();

			int affectedRow = jdbcTemplate.update(con -> {

				PreparedStatement ps = con.prepareStatement(insertQueryForStudent, new String[]{"pateint_id"});

				ps.setString(1, insertPatient.getFirstName());
				ps.setString(2, insertPatient.getLastName());
				ps.setString(3, insertPatient.getGender());
				ps.setString(4, insertPatient.getAddress());
				ps.setString(5, insertPatient.getEmail());
				ps.setString(6, insertPatient.getPhone());
				ps.setString(7, insertPatient.getMajor());
				ps.setString(8, insertPatient.getDescription());
				ps.setDouble(9, insertPatient.getGpa());
				ps.setInt(10, insertPatient.getTotalMArks());

				return ps;

			}, keyHolder);

			Number generatedKey = keyHolder.getKey();
			Long patientId = (generatedKey != null) ? generatedKey.longValue() : null;

			System.out.println("Generated pateint ID: " + patientId);

			boolean isSuccess = (affectedRow > 0);

			return isSuccess;

		} catch (Exception e) {
			return null;
		}

	}
	
	
	public List<SelectPatient> findAllPatient() {

		String sql = "SELECT * FROM student_info_ref";

		try {

			List<SelectPatient> SelectStudents = jdbcTemplate.query(sql, new PatientRowMapper());

			return SelectStudents;

		} catch (Exception e) {
			// TODO: handle exception
			return null;
		}

	}

	
	//////////JdbcTemplete Select Data Using Object For query Method//////////

	public SelectPatient selectPatientById(Long patientLong) {


		try {

			return jdbcTemplate.queryForObject(queryObjectSelectDataInJdbcTemplete, new Object[]{patientLong}, new PatientRowMapper());
		} catch (Exception e) {
			// TODO: handle exception
			return null;
		}
	}


	


	public List<SelectPatient> findAllPatientByList() {


		try {

			List<SelectPatient> selectPatients = new ArrayList<>();

			List<Map<String, Object>> rows = jdbcTemplate.queryForList(queryListSelectDataInJdbcTemplete);

			for (Map row : rows) {

				SelectPatient selectPatient = new SelectPatient();

				selectPatient.setPatientId(((Integer) row.get("patient_id")).longValue());
				selectPatient.setFirstName((String) row.get("first_name"));
				selectPatient.setLastName((String) row.get("last_name"));
				selectPatient.setDateOfBirth(((Date) row.get("date_of_birth")).toLocalDate());
				selectPatient.setGender((String) row.get("gender"));
				selectPatient.setAddress((String) row.get("address"));
				selectPatient.setEmail((String) row.get("email"));
				selectPatient.setPhone((String) row.get("phone"));
				selectPatient.setMajor((String) row.get("major"));
				selectPatient.setDescription((String) row.get("description"));
				selectPatient.setEntryDate(((Date) row.get("EntryDate")).toLocalDate());
				selectPatient.setGpa((Double) row.get("gpa"));
				selectPatient.setTotalMArks((Integer) row.get("total_marks"));
				selectPatient.setIsActive((Boolean) row.get("is_active"));
				selectPatients.add(selectPatient);
			}

			return selectPatients;

		} catch (Exception e) {
			return null;
		}

	}


	public Map<String, Object> selectQueryForMap(Long patientId) {


		try {


			Map<String, Object> result = jdbcTemplate.queryForMap(queryForMapSelectDataInJdbcT, patientId);


			return result;

		} catch (Exception e) {
			// TODO: handle exception
			return null;
		}


	}



/////////////////////////////////Query For Object Using NamedJdbcTemplete///////////////////


	public SelectPatient selectPatientByIdUsingNamedJdbcTemplete(Long patientId) {
		try {

			MapSqlParameterSource mapSqlParameterSource =new MapSqlParameterSource() ;
			mapSqlParameterSource.addValue("patient_id", patientId);

			return  namedParameterJdbcTemplate.queryForObject(queryForObjectSelectDataInNamedTem,mapSqlParameterSource,new PatientRowMapper());

		} catch (Exception e) {
			// TODO: handle exception
			return null;
		}
	}



/////////////////////////////////Query For List Using NamedJdbcTemplete///////////////////

public List<SelectPatient> selectPatientByQueryForListUsingNamedJdbcTemplete(Long patientId, String firstName){

		try {

			List<SelectPatient> selectStudents = new ArrayList<>();

			MapSqlParameterSource parameters = new MapSqlParameterSource();
			parameters.addValue("patientId", patientId);
			parameters.addValue("firstName", firstName);




			List <Map<String, Object>> rows = namedParameterJdbcTemplate.queryForList(queryForListSelectDataInNamedTem, parameters);


			for (Map<String,Object> row : rows) {

				SelectPatient selectPatient = new SelectPatient();
				selectPatient.setPatientId(((Integer) row.get("patient_id")).longValue());
				selectPatient.setFirstName((String) row.get("first_name"));
				selectPatient.setLastName((String) row.get("last_name"));
				selectPatient.setDateOfBirth(((Date) row.get("date_of_birth")).toLocalDate());
				selectPatient.setGender((String) row.get("gender"));
				selectPatient.setAddress((String) row.get("address"));
				selectPatient.setEmail((String) row.get("email"));
				selectPatient.setPhone((String) row.get("phone"));
				selectPatient.setMajor((String) row.get("major"));
				selectPatient.setDescription((String) row.get("description"));
				selectPatient.setEntryDate(((Date) row.get("EntryDate")).toLocalDate());
				selectPatient.setGpa((Double) row.get("gpa"));
				selectPatient.setTotalMArks((Integer) row.get("total_marks"));
				selectPatient.setIsActive((Boolean) row.get("is_active"));
				selectStudents.add(selectPatient);
			}

			return selectStudents;

				}catch (Exception e){
			return null;
		}
		
}



		 
		


//////////////////////////////////////////////////////////////////////////////////////////////



	
	

	
	}



